============================================================================================================
Binary Tree Preorder Traversal

Given a binary tree, return the preorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
-------------------------------------------------------------------------------------------------------------
Solution 1
We can use recursion technique to solve the problem.
We use a List to store nodes' values.
Firstly, we put the root's value into the List.
Then, if the root has left child, repeat the method. The same to the right child if the root has one.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> result = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null){
            return result;
        }
        result.add(root.val);
        if (root.left != null)
            preorderTraversal(root.left);
        if (root.right != null)
            preorderTraversal(root.right);
        return result;
    }
}
-------------------------------------------------------------------------------------------------------------
Solution 2
We can use a stack data structure to solve the problem.
Stack is a first in last out data structure.
Firstly, we put the root into the stack.
While the stack is not empty, we pop up the top element in the stack, and put its value in a list.
Each time we pop up one element from the stack, we check if the element has left or right child.
Because the property of stack, we put the right child of root into stack first,
then put the left child of root to the stack if the root has right child or left child.
Loop the whole process untill the stack is empty.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution{
  public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> result = new ArrayList<>();
    if (root == null){
      return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
      TreeNode node = stack.pop();
      result.add(node.val);
      if (!node.right){
        stack.push(node.right);
      }
      if (!node.left){
        stack.push(node.left);
      }
    }
    return result;
  }
}
============================================================================================================
Binary Tree Inorder Traversal

Given a binary tree, return the inorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
-------------------------------------------------------------------------------------------------------------
Solution 1
Refer to Solution 1 of Binary Tree Preorder Traversal
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> result = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null){
            return result;
        }
        inorderTraversal(root.left);
        result.add(root.val);
        inorderTraversal(root.right);
        return result;
    }
}
-------------------------------------------------------------------------------------------------------------
Solution 2
We use a stack to solve the problem.
We use a List to store all nodes's values.
Add left nodes all the way to the stack from root node, 
then pop up the top element in the stack marked as current node,
add current node value to list, then move to its right node if possible, repeat the loop.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            while (cur != null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            result.add(cur.val);
            cur = cur.right;
        }
        return result;
    }
}
=====================================================================================================================
Binary Tree Postorder Traversal
Given a binary tree, return the postorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]
--------------------------------------------------------------------------------------------------------------------
Iterative solution:
Use two stacks to solve the problem.
Use stack1 to store the root of every subtree
Use stack2 to store nodes poped from stack1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(root);
        while (!stack1.isEmpty()){
            TreeNode cur = stack1.pop();
            stack2.push(cur);
            if (cur.left != null){
                stack1.push(cur.left);
            }
            if (cur.right != null){
                stack1.push(cur.right);
            }
        }
        while (!stack2.isEmpty()){
            result.add(stack2.pop().val);
        }
        return result;
    }
}
=====================================================================================================================
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

return its level order traversal as:

[
  [3],
  [9,20],
  [15,7]
]
-----------------------------------------------------------------------------------------------------------------------
We use Queue data structure to solve the problem.
There are two scenarios: 
1. If the root is null, return an empty List.
2. If the root is not null, we put the root in the queue, and we use a variable to store the current size of the queue,
   then we poll out all nodes of current size, put them in a level list, if the nodes of current size have children,
   we put them to the queue.
   If the queue is not empty, repeat the circle.
   
 /**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while (!q.isEmpty()){
            int size = q.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; i++){
                TreeNode node = q.poll();
                list.add(node.val);
                if (node.left != null){
                    q.offer(node.left);
                }
                if (node.right != null){
                    q.offer(node.right);
                }
            }
            result.add(list);
        }
        return result;
    }
}
============================================================================================================
