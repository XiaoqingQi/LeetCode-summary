============================================================================================================
Binary Tree Preorder Traversal

Given a binary tree, return the preorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
-------------------------------------------------------------------------------------------------------------
Solution 1
We can use recursion technique to solve the problem.
We use a List to store nodes' values.
Firstly, we put the root's value into the List.
Then, if the root has left child, repeat the method. The same to the right child if the root has one.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> result = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null){
            return result;
        }
        result.add(root.val);
        if (root.left != null)
            preorderTraversal(root.left);
        if (root.right != null)
            preorderTraversal(root.right);
        return result;
    }
}
-------------------------------------------------------------------------------------------------------------
Solution 2
We can use a stack data structure to solve the problem.
Stack is a first in last out data structure.
Firstly, we put the root into the stack.
While the stack is not empty, we pop up the top element in the stack, and put its value in a list.
Each time we pop up one element from the stack, we check if the element has left or right child.
Because the property of stack, we put the right child of root into stack first,
then put the left child of root to the stack if the root has right child or left child.
Loop the whole process untill the stack is empty.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution{
  public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> result = new ArrayList<>();
    if (root == null){
      return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
      TreeNode node = stack.pop();
      result.add(node.val);
      if (!node.right){
        stack.push(node.right);
      }
      if (!node.left){
        stack.push(node.left);
      }
    }
    return result;
  }
}
============================================================================================================
Binary Tree Inorder Traversal

Given a binary tree, return the inorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
-------------------------------------------------------------------------------------------------------------
Solution 1
Refer to Solution 1 of Binary Tree Preorder Traversal
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> result = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null){
            return result;
        }
        inorderTraversal(root.left);
        result.add(root.val);
        inorderTraversal(root.right);
        return result;
    }
}
-------------------------------------------------------------------------------------------------------------
Solution 2
We use a stack to solve the problem.
We use a List to store all nodes's values.
Add left nodes all the way to the stack from root node, 
then pop up the top element in the stack marked as current node,
add current node value to list, then move to its right node if possible, repeat the loop.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            while (cur != null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            result.add(cur.val);
            cur = cur.right;
        }
        return result;
    }
}
============================================================================================================
