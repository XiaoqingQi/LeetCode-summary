==============================================================================================================================
1. Minimal Tree
  Given a sorted array (increasing order) with unqiue integer elements, write an algorithm to create a binary search tree 
  with minimal height.
------------------------------------------------------------------------------------------------------------------------------
Solution:
  To create a tree of minimal height, we need to math the number of nodes in the left subtree to the number of nodes in the 
  right subtree as much as possible.
  This means that we want the root to be the middle of the array, since this would mean that half the elements would be less
  than the root and half would be greater than the root.
  So during the process, the middle of each subsection of the array becomes the root of the node.
  The left half of the array will become our left subtree, the right half of the array will become the right subtree.
  We can do this recursively.
  The algorithm is as follows:
    Insert into the tree the middle of the array.
    Insert into the left subtree the left subarray elements.
    Insert into the right subtree the rignth subarray elements.
    
    public class MinumalTree {
      public TreeNode createMinimalBST(int[] array) {
          int start = 0;
          int end = array.length - 1;
          return help(array, start, end);
      }

      private TreeNode help(int[] array, int start, int end) {
          //base case
          if (end < start){
              return null;
          }
          int mid = (start + end)/2;
          TreeNode root = new TreeNode(array[mid]);
          root.left = help(array, start, mid - 1);
          root.right = help(array, mid + 1, end);
          return root;
      }
    
    }
    class TreeNode {
        int value;
        TreeNode left;
        TreeNode right;

        public TreeNode(int value) {
            this.value = value;
        }
    }
==============================================================================================================================
2.List of Depths
  Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth.
-----------------------------------------------------------------------------------------------------------------------------
Solution 1:
  We can solve this problem using depth-first search.
  At each level, we put the nodes on that level into the corresponding linked list.
  
  class TreeNode {
    int value;
    TreeNode left;
    TreeNode right;
    public TreeNode (int v){
      this.value = v;
    }
  }
  public class Demo {
    public ArrayList<LinkedList<TreeNode>> createLevelLinkedList(TreeNode root){
      ArrayList<LinkedList<TreeNode>> lists = new ArrayList<>();
      help(root, result, 0);
      return lists;
    }
    public void help(TreeNode root, ArrayList<LinkedList<TreeNode>> lists, int level){
      if (root == null) {
        return;
      }
      LinkedList<TreeNode> list = null;
      //Levels are always traversed in order. So if this is the first time we've visited level i, we must have seen
      //level 0 through i -1. We can therefore add the level at the end.
      if (lists.size() == level){ //Level not contained in list
        list = new LinkedList<>();
        lists.add(list);
      } else {
        list = lists.get(level);
    }
      list.add(root);
      help(root.left, lists, level + 1);
      help(root.right, lists, level + 1);
  }
-----------------------------------------------------------------------------------------------------------------------------
Solution 2:
  We can solve the problem using breath-first search.
  We interate through the tree from level 0, to level 1 level 2, and so on.
  With each level i, we will have fully visited all the nodes on level i - 1.
  So to get all nodes on level i, we can simply look at all children of the nodes of levle i - 1.
  public class Demo {
    public ArrayList<LinkedList<TreeNode>> createLevelLinkedList(TreeNode root){
      ArrayList<LinkedList<TreeNode>> lists = new ArrayList<>();
      if (root == null){
        return lists;
      }
      LinkedList<TreeNode> current = new LinkedList<>();
      current.add(root);
      while (current.size > 0) {
      //Add previous level
        lists.add(current);
        LinkedList<TreeNode> parents = current;
        current = new LinkedList<>();
        for (TreeNode parent : parents){
          if (parent.left != null) {
            current.add(parent.left);
          }
          if (parent.right != null){
            current.add(parent.right);
          }
        }
      }
      return lists;
    }
  }
==============================================================================================================================
3. Check Balanced
  Implement a function to check if a binary tree is balanced.
  A balanced tree is a tree that the height of the two subtrees of any node never differ by more than one.
------------------------------------------------------------------------------------------------------------------------------
Solution:
  We can simply recurse through the entire tree, and for each node, compute the heights of each subtree.
  public class BalancedTree {
    private int getHeight(TreeNode node){
      //Define the height of a null tree to be -1
        if (node == null){
            return -1;
        }
        return Math.max(getHeight(node.left) + 1, getHeight(node.right) + 1);
    }
    public boolean isBalanced(TreeNode root){
        //Base case
        if (root == null){
            return true;
        }
        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);
        if (Math.abs(leftHeight - rightHeight) > 1){
            return false;
        } else {
            //Recurse
            return isBalanced(root.left) && isBalanced(root.right);
        }
    }
}

In this method, on each node, we recurse through its entire subtree.
This means that getHeight is called repeatedly on the same nodes.
It takes O(Nlog N) time.

In order to cut out some of the calls to getHeight, we notice that the getHeight could actually check if the tree is
balanced at the same time as it's checking heights. And if we dicover that subtree isnot balanced, just return an error code.
So the improved algorithm is checkding the height of each subtree as we recurse dowm from the root.
On each node, we recursively get the heights of the lfet and right subtree through the checkHeight mehthod.
If the subtree is balanced, then checkHeight will return the actual height of the subtree.
If the subtree isnot balanced, then checkHeight will return an error code.
We will immediately break and return the error code from the current call.
This algorithm takes O(N) time and O(H) space, H is the height of the tree.

  private int checkHeight(TreeNode node){
    if (node == null){
      return -1;
    }
    int leftHeight = checkHeight(node.left);
    if (leftHeight == Integer.MIN_VALUE){
      return Integer.MIN_VALUE;
    }
    int rightHeight = checkHeight(node.right);
    if (rightHeight == Integer.MIN_VALUE){
      return Integer.MIN_VALUE;
    }
    if (Math.abs(leftHeight - rightHeight) > 1){
      return Integer.MIN_VALUE;
    } else {
      return Math.max(leftHeight, rightHeight) + 1;
    }
  }
  public boolean isBalanced(TreeNode root){
    return checkHeight(root) != Integer.MIN_VALUE;
  }
=============================================================================================================================
4. Validate BST
  Implement a function to check if a binary tree is a binary search tree.
-----------------------------------------------------------------------------------------------------------------------------
Solution 1:
  We can do an in-order traversal, copy the elements to an array, and then check to see if the array is sorted.
  This algorithm takes extra memory, and the only problem is that it can't handle duplicate vaues in the tree properly.
  So in order to use this algorithm, we need to assume that the tree cann't have duplicate values.
    private int index = 0;
    public boolean checkBST(TreeNode root){
      int[] array = new int[root.size];
      copyBST(root, array);
      for (int i = 1; i < array.length; i++){
        if (array[i] <= array[i-1]) return false;
      }
      return true;
    }
    private void copyBST(TreeNode node, int[] array){
      if (node == null){
        return;
      }
      copyBST(node.left, array);
      array[index++] = node.value;
      copyBST(node.right, array);
    }
    
  When we examine this solution, we find that we use the array only to compare an element to the previous element.
  So we can just track the last element we saw and compare it with the current element as we go.
  public class ValidateBST {
    Integer last_printed = null;
    public boolean validateBST(TreeNode root){
        //Base case
        if (root == null){
            return true;
        }
        //Check and recurse left
        if (!validateBST(root.left)){
            return false;
        }
        //Check current
        if (last_printed != null && root.value <= last_printed){
            return false;
        }
        last_printed = root.value;
        //Check and recurse right
        if (!validateBST(root.right)){
            return false;
        }
        return true;
    }
}
-----------------------------------------------------------------------------------------------------------------------------
Solution 2:
  The condition for a tree to be a binary search tree is that all left nodes must be less than or equal to the current node,
  all right nodes must be greater than the current node.
  We can use two variables to track the min and max values, as we iterate through the tree, we can verify whether each node 
  is within the range.
  When we branch left, we update the max value. When we branch right, we update the min value.
  This algorithm takes O(N) time.
    public boolean checkBST(TreeNode root){
      return check(root, null, null);
    }
    private boolean check(TreeNode node, Integer min, Integer max){
      if (node == null){
        return true;
      }
      if ((min != null && node.value <= min) || (max != null && node.valu > max)){
        return false;
      }
      if (!check(root.left, min, node.value) || !check(root.right, node.value, max)){
        return false;
      }
      return true;
    }
=============================================================================================================================
5.Lowest Common Ancestor
Find the first commont ancestro of two nodes in a binary tree.
-----------------------------------------------------------------------------------------------------------------------------
Solution 1
  With links to Parents
  If each node has a link to its parent, we could trace p and q's paths up until they intersect.
    TreeNode commonAncestor(TreeNode p, TreeNode q){
      int dif = depth(p) - depth(q);
      TreeNode first = dif > 0 ? q : p; //get shadlower node
      TreeNode second = dif > 0 ? p : q; //get deeper node
      second = goUpBy(second, Math.abs(dif)); //move deeper node up
      //Find where paths intersect
      while (first != second && first != null && second != null){
        first = first.parent;
        second = second.parent;
      }
      return fist == null || second == null ? null : first;
    }
    TreeNode goUpBy(TreeNode node, int depth){
      while (depth > 0 && node != null){
        node = node.parent;
        depth--;
      }
      return node;
    }
    int depth(TreeNode node){
      int depth = 0;
      while (node != null){
        node = node.parent;
        depth++;
      }
      return depth;
    }
-----------------------------------------------------------------------------------------------------------------------------
Solution 2
  Without links to parent
  We could follow a chain in which p and q are on the same side.
  If p and q are both on the left of the node, branch left to look for the common ancestor.
  If they are both on the right, branch right to look for the common ancestor.
  When p and q are no longer on the same side, then we must have found the first common ancestor.
    TreeNode commonAncestor(TreeNode root, TreeNode p, TreeNode q){
    //Check if p or q is in the tree or not
      if (!cover(root, p) || !cover(root,q)){
      return null;
      return helper(root, p, q);
    }
    TreeNode helper(TreeNode root, TreeNode p, TreeNode q){
      if (root == null || root == p || root == q){
        return root;
      }
      boolean pIsOnLeft = cover(root.left, p);
      boolean qIsOnLeft = cover(root.left, q);
      if (pIsOnLeft != qIsOnLeft){ //Nodes are on different side
        return root;
      }
      TreeNode childSide = pIsOnLeft ? root.left : root.right;
      return helper(childSide, p, q);
    }
    boolean cover(TreeNode root, TreeNode p){
      if (root == null){
        return false;
      }
      if (root == p){
        return true;
      }
      return cover(root.left, p) || cover(root.right, p);
    }
-----------------------------------------------------------------------------------------------------------------------------
Solution 3
  Without links to parent
  We can find the path from the root to node p and q.
  Then we check the two paths to find the first common ancestor.
     public TreeNode lowestCommonAncestro(TreeNode root, TreeNode p, TreeNode q){
        Stack<TreeNode> pathTop = pathToNode(root, p);
        Stack<TreeNode> pathToq = pathToNode(root, q);
        TreeNode ancestor = null;
        while (!pathTop.isEmpty() && !pathToq.isEmpty()){
            TreeNode node1 = pathTop.pop();
            TreeNode node2 = pathToq.pop();
            if (node1 == node2){
                ancestor = node1;
            } else {
                return ancestor;
            }
        }
        return null;
    }

    private Stack<TreeNode> pathToNode(TreeNode root, TreeNode node) {
        if (root == node){
            Stack<TreeNode> stack = new Stack<>();
            stack.push(node);
            return stack;
        }
        if (root == null){
            return null;
        }
        Stack<TreeNode> leftPath = pathToNode(root.left, node);
        if (leftPath != null){
            leftPath.add(root);
            return leftPath;
        }
        Stack<TreeNode> rightPath = pathToNode(root.right, node);
        if (rightPath != null){
            rightPath.add(root);
            return rightPath;
        }
        return null;
    }
=============================================================================================================================
6.Check Subtree
  T1 and T2 are two very large binary trees, with T1 much bigger than T2. Create an algorithm to determine if T2 is a subtree of T1.
-----------------------------------------------------------------------------------------------------------------------------
 Solution 1
  In this problem, we could consider comparing string representations of traversals of each tree.
  If T2 is a subtree of T1, then T2's traversal should be a substring of T1.
  Should we use in-order traversal?
  Considering a scenario in which we were using a binary search tree.
  A binary search tree's in-order traversal always prints out the values in sorted order.
  Therefore, two binary search trees with the same values will always have the same in-order traversals,
  even if their structure is different.
  What about a pre-order traversal?
  We know the first element in pre-order traversal is the root node.
  Unfortunately, trees with different structure could still have the same pre-order traversal.
  There's a simple fix though.
  We can store NULL node in pre-order traversal string as a special character, like an 'X'.
  As long as we represent the NULL nodes, the pre-order traversal of a tree is unique.
  That is, if two trees have the same pre-oreder traversal, then we know they are identical trees in values and structure.
  A pre-order traversal always starts at the root and, from there, the path we take is defineed by the traversal.
  Now consider the subtree problem, if T2's pre-order traversal is a substring of T1's pre-order traversal, then T2's root element
  must be found in T1. If we do a pre-order traversal from this element in T1, we will follow an identical path to T2's traversal.
  Therefor T2 is a subtree of T1.
  This approach takes O(n+m) time and O(n+m) space.
  
    boolean containsTree(TreeNode t1, TreeNode t2){
      StringBuilder string1 = new StringBuilder();
      StringBuilder string2 = new StringBuilder();
      getOrderString(t1, string1);
      getOrderString(t2, string2);
      return string1.indexOf(string2.toString()) != -1;
    }
    void getOrderString(TreeNode node, StringBuilder sb){
      if (node == null){
        sb.append("X");
        return;
      }
      sb.append(node.data + " "); //add root
      getOrderString(node.left, sb); //add left
      getOrderString(node.right, sb); //add right
    }
-----------------------------------------------------------------------------------------------------------------------------
Solution 2
  This approach is to search through the larger tree, T1. 
  Each time a node in T1 mathches the root in T2, call matchTree.
  The matchTree method will call the subtrees to see if they are identical.
  
    boolean containsTree(TreeNode t1, TreeNode t2){
      if (t2 == null) return true; //The empty tree is always a subtree
      return subTree(t1, t2);
    }
    boolean subTree(TreeNode t1, TreeNode t2){
      if (t1 == null){
        return false; //big tree empty & subtree still not found
      } else if (t1.value == t2.value && matchTree(t1, t2)){
        return true;
      }
      return subTree(t1.left, t2) || subTree(t1.right, t2);
    }
    boolean matchTree(TreeNode t1, TreeNode t2){
      if (t1 == null && t2 == null){
        retur true; //nothing left in the subtree
      } else if (t1 == null || t2 == null){
        return false; 
      } else if (t1.value != t2.value){
        return false;// values don't match
      } else {
      return matchTree(t1.left, t2.left) && matchTree(t1.right, t2.right);
    }
=============================================================================================================================
7. Random Node
    You are implementing a binary search tree class from scratch, which, in addition to insert, find, and delete, has a method
    getRandomNode() which returns a random node from the tree. All nodes should be equally likely to be choosen.
    Design and implement an algorithm to getRandomNode(), and explain how you would implement the rest of the methods.
-----------------------------------------------------------------------------------------------------------------------------
Solution 1:
  We can copy all the nodes to an array, and return a random element in the array.
  This solution will take O(N) time and O(N) space.
-----------------------------------------------------------------------------------------------------------------------------
Solution 2:
  We can label all the nodes with an index from 1 to N and label them in binary search tree order(that is in-order traversal).
  Then we call getRandomNode, we generate a random index between 1 and N.
  Then we can use the binary search tree search to find this index.
  However, this leads to a problem, when we insert a node or delete a node, all of the nodes might need to be updated.
  This can take O(N) time.
-----------------------------------------------------------------------------------------------------------------------------
Solution 3:
  Since we have N nodes, we must return each node with 1/N probability.
  The odds of picking something-anything-from the left must be the sum of each individual probability.
  The odds of picking something from the left must have probability left-size * 1/N.
  This shoud therefore be the odds of going left.
  Likewise, the odds of going right is right-size * 1/N.
  This means that each node must know the size of the nodes on the left and the size of the nodes on the right.
  We can store a size variable in each node, and increment size on inserts and decrement size on deletes.
  
  class TreeNode{
    private int value;
    public TreeNode left;
    public TreeNode right;
    private int size;
    public TreeNode(int data){
      value = data;
      size = 1;
    }
    public int getSize(){
      return this.size;
    }
    public int getValue(){
      return this.value;
    }
    public TreeNode getRandomNode(){
      int leftSize = left == null ? 0 : left.size();
      Random random = new Random();
      int index = random.nextInt(size);
      if (size < leftSize){
        return left.getRandomNode();
      } else if (index == leftSize){
        return this;
      } else {
        return right.getRandomNode();
      }
    }
    public void insert(int d){
      if (d <= value){
        if (left == null){
          left = new TreeNode(d);
        } else {
        left.insert(d);
      } else {
        if (right == null){
          right = new TreeNode(d);
        } else {
        right.insert(d);
      }
      size++;
    }
    public TreeNode find(int d){
      if (d == value){
        return this;
      } else if (d < value){
        return left != null ? left.find(d) : null;
      } else {
        return right != null ? right.find(d) : null;
       }
       return null;
    }
    
  }
=============================================================================================================================
8. Paths with Sum
  You are given a binary tree in which each node contains an integer value.
  Design an algorithm to count the number of paths that sum to a given value.
  The path does not need to start or end at the root or leaf, but it must go downwards.
-----------------------------------------------------------------------------------------------------------------------------
Solution 1:
  Brute Force
  In this approach, we just look at all possible paths.
  We traverse to each node, at each node, we recursively try all paths downwards, tracking the sum as we go.
  As soon as we hit the target sum, we increment the total.
  Consider that node at depth d will be "touched" by d nodes above it.
  The runtime is O(NlogN).(in a balanced binary tree)
  
    int countPathsWithSum(TreeNode root, int target){
      if (root == null){
        return 0;
      }
      int pathFromRoot = countPathsWithSumFromNode(root, target, 0);
      int pathOnLeft = countPathsWithSum(root.left, target);
      int pathOnRight = countPathsWithSum(root.right, target);
      return pathFromRoot + pathOnLeft + pathOnRight;
    }
    private int countPathsWithSumFromNode(TreeNode root, int targetSum, int currentSum){
      if (root == null){ //base case
        return 0;
      }
      currentSum += root.value;
      int total = 0;
      if (currentSum == targetSum){
        total++;
      }
      total += countPathsWithSumFromNode(root.left, targetSum, currentSum);
      total += countPathsWithSumFromNode(root.right, targetSum, currentSum);
      return total;
    }
-----------------------------------------------------------------------------------------------------------------------------
Solution 2:
  Let's isolate a given path and treat it as an array. 
  Consider a path like:
  index: 0  1  2  3   4   5  6  7  8
        10->5->1->2->-1->-1->7->1->2
  We need to know how many contiguous subsequences in this array sum to a target sum.
  Since we are just looking for the number of paths, we can use a hash table.
  We can interate through the array, build a hash table that maps from a currentSum to the number of times we have seen that sum.
  So for each element(y) in the array, look up currentSum(y) - targetSum in the hash table.
  The number in the hash table will tell you the number of paths with sum targetSum that end at element y.
  Let's look at the example above.
  At index 7, the value of currentSum(7) is 24. If taregetSum is 8, then we look up 16 in the hash table.
  This would have a value of 2 (originating from index 2 and inde5).
  As we can see above, indexes 3 through 7 and indexes 6 through 7 have sums of 8.
  Let's review this on a tree:
    as we visit each node:
    1. Track its currentSum. We'll take this in as a parameter and immediately increment it by node.value.
    2. Look up currentSum - targetSum in the hash table. The value there indicates the total number. Set the totalPaths to this value.
    3. If currentSum equals to tagetSum, then, there's one additional path that starts at the root. Increment the totalPahts.
    4. Add currentSum to the hash table (incrementing the value of it's already there).
    5. Recurse left and right, counting the number of pahts with sum targetSum.
    6. After we're done recursing left and right, decrement the value of currentSum in the hash table.
       This is essentially backing out of our work; 
       it reverses the changes to the hash table so that other nodes don't use it (since we're done with node).
    This algorithm will take O(N) time.
       
     int countPahtsWithSum(TreeNode root, int targetSum){
        return countPahtsWithSumToNode(root, targetSum, 0, new HashMap<Integer, Integer>());
     }
     int countPahtsWithSumToNode(TreeNode node, int targetSum, int currentSum, HashMap<Integer, Integer> map){
       if (root == null){ //base case
            return 0;
          }
          //Count pahts with sum ending at the current node
          currentSum += node.value;
          int sum = currentSum - targetSum;
          int totalPahts = map.getOrDefault(sum, 0);
          if (currentSum == targetSum){
            totalPaths++;
          }
          //Increment map, recurse, then decrement map
          incrementHashTable(map, currentsSum, 1);
          total += countPahtsWithSumToNode(root.left, targetSum, currentSum, map);
          total += countPahtsWithSumToNode(root.right, targetSum, currentSum, map);
          incrementHashTable(map, currentSum, -1);
          return totalPahts.
     }
     void incrementHashTable(HashMap<Integer, Integer> map, int key, int delta){
      int newCount = map.getOrDefault(key, 0) + 1;
      if (newCount == 0){ //Remove wehn zero to redure space usage
        map.remove(key);
      } else {
      map.put(key, newCount);
     }
============================================================================================================
9. Binary Tree Preorder Traversal

Given a binary tree, return the preorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
-------------------------------------------------------------------------------------------------------------
Solution 1
We can use recursion technique to solve the problem.
We use a List to store nodes' values.
Firstly, we put the root's value into the List.
Then, if the root has left child, repeat the method. The same to the right child if the root has one.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> result = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null){
            return result;
        }
        result.add(root.val);
        if (root.left != null)
            preorderTraversal(root.left);
        if (root.right != null)
            preorderTraversal(root.right);
        return result;
    }
}
-------------------------------------------------------------------------------------------------------------
Solution 2
We can use a stack data structure to solve the problem.
Stack is a first in last out data structure.
Firstly, we put the root into the stack.
While the stack is not empty, we pop up the top element in the stack, and put its value in a list.
Each time we pop up one element from the stack, we check if the element has left or right child.
Because the property of stack, we put the right child of root into stack first,
then put the left child of root to the stack if the root has right child or left child.
Loop the whole process untill the stack is empty.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution{
  public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> result = new ArrayList<>();
    if (root == null){
      return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
      TreeNode node = stack.pop();
      result.add(node.val);
      if (!node.right){
        stack.push(node.right);
      }
      if (!node.left){
        stack.push(node.left);
      }
    }
    return result;
  }
}
============================================================================================================
Binary Tree Inorder Traversal

Given a binary tree, return the inorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
-------------------------------------------------------------------------------------------------------------
Solution 1
Refer to Solution 1 of Binary Tree Preorder Traversal
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> result = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null){
            return result;
        }
        inorderTraversal(root.left);
        result.add(root.val);
        inorderTraversal(root.right);
        return result;
    }
}
-------------------------------------------------------------------------------------------------------------
Solution 2
We use a stack to solve the problem.
We use a List to store all nodes's values.
Add left nodes all the way to the stack from root node, 
then pop up the top element in the stack marked as current node,
add current node value to list, then move to its right node if possible, repeat the loop.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            while (cur != null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            result.add(cur.val);
            cur = cur.right;
        }
        return result;
    }
}
=====================================================================================================================
Binary Tree Postorder Traversal
Given a binary tree, return the postorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]
--------------------------------------------------------------------------------------------------------------------
Iterative solution:
Use two stacks to solve the problem.
Use stack1 to store the root of every subtree
Use stack2 to store nodes poped from stack1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(root);
        while (!stack1.isEmpty()){
            TreeNode cur = stack1.pop();
            stack2.push(cur);
            if (cur.left != null){
                stack1.push(cur.left);
            }
            if (cur.right != null){
                stack1.push(cur.right);
            }
        }
        while (!stack2.isEmpty()){
            result.add(stack2.pop().val);
        }
        return result;
    }
}
=====================================================================================================================
10. Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

return its level order traversal as:

[
  [3],
  [9,20],
  [15,7]
]
-----------------------------------------------------------------------------------------------------------------------
We use Queue data structure to solve the problem.
There are two scenarios: 
1. If the root is null, return an empty List.
2. If the root is not null, we put the root in the queue, and we use a variable to store the current size of the queue,
   then we poll out all nodes of current size, put them in a level list, if the nodes of current size have children,
   we put them to the queue.
   If the queue is not empty, repeat the circle.
   
 /**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while (!q.isEmpty()){
            int size = q.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; i++){
                TreeNode node = q.poll();
                list.add(node.val);
                if (node.left != null){
                    q.offer(node.left);
                }
                if (node.right != null){
                    q.offer(node.right);
                }
            }
            result.add(list);
        }
        return result;
    }
}
============================================================================================================
