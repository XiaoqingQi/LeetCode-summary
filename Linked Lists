==============================================================================================================================
1.Remove Duplicates
Write code to remove duplicates from an unsorted linked list.
Follow up:
How would you solve this problem if a temporary buffer is not allowed ?
-----------------------------------------------------------------------------------------------------------------------------
Solution 1: 
In order to move duplicates from a linked list, we need to be able to track duplicates.
A simple hash table will work well here.
We iterate through the linked list, add each element to hash table.
When we found a duplicate element, we remove it and continue iterating.
We can do this all in one pass since we're using linked list.
It will take O(N) time, where N is the number of elements in the linked list.
import java.util.HashSet;

class LinkedListNode{
    int val;
    LinkedListNode next;

    public LinkedListNode(int val) {
        this.val = val;
    }

    public LinkedListNode(int val, LinkedListNode next) {
        this.val = val;
        this.next = next;
    }
}
public class RemoveDuplicates {
    void removeDups(LinkedListNode head){
        HashSet<Integer> hashSet = new HashSet<>();
        LinkedListNode pre = null;
        while (head != null){
            if (hashSet.contains(head.val)){
                pre.next = head.next;
            } else {
                hashSet.add(head.val);
                pre = head;
            }
            head = head.next;
        }
    }
 }
 ---------------------------------------------------------------------------------------------------------------------------
 Solution 2:
 No buffer allowed
 If we don't have a buffer, we can iterate with two pointers: current which iterates through the linked list,
 runner which checks all subsequent nodes for duplicates.
 It will take O(N2) time and O(1) space.
 
 void removeDups(LinkedListNode head){
        LinkedListNode current = head;
        while (current != null){
            LinkedListNode runner = current;
            //Remove future nodes that have the same value
            while (runner.next != null){
                if (runner.next.val == current.val){
                    runner.next = runner.next.next;
                }  else {
                    runner = runner.next;
                }
            }
            current = current.next;
        }
  }
 ==============================================================================================================================
 2.Return Kth to last
 Implement an algorithm to find the kth to last element of a singly linked list.
 Note that if k = 0, the method would return the last element, k = 1 would return the second to last element.
 The linked list size is not known.
 ------------------------------------------------------------------------------------------------------------------------------
 Solution 1:
 Recursive
 We recurses through the linked list.
 When it hits the end, the method passes back a counter set to 0.
 Each parent call adds 1 to this counter.
 When the counter equals to k, we know we have reached the kth to last element of the linked list.
 It will take O(N) space due to the recursive calls.
 But we can't pass back a node and a counter using normal return statements.
 One way to do this is to change the problme to simply printing the kth to last element.
 Then we can pass back the value of the counter simply througt return values.
 int kthToLast(LinkedListNode head, int k){
  if (head == null){
    return 0;
  }
  int index = kthToLast(head.next, k);
  if (index == k){
    System.out.println(k + "th to last node is " + head.val);
  }
  return index;
 }
 Another way is to create a class that stores both the node and the counter, and return an instance of that class.
 ------------------------------------------------------------------------------------------------------------------------------
 Solution 2:
 Iterative
 We can use two pointers, p1 and p2.
 We place them k nodes apart in the linked list by putting p1 at the beginning and moving p2 k nodes into the list.
 Then we move them at the same pace.
 When p2 hit the end of the linked list, p1 would point the kth to last element.
 This algorithm takes O(1) space and O(N) space.
 
 LinkedListNode nthToLast(LinkedListNode head, int k){
  LinkedListNode p1 = head;
  LinkedListNode p2 = head;
  //move p2 k nodes apart from p1
  for (int i = 0; i < k; i++){
    if (p2 == null){
      return null;
    }
    p2 = p2.next;
  }
  while (p2 != null){
    p1 = p1.next;
    p2 = p2.next;
  }
  return p1;
  
 }
 ==============================================================================================================================
 3. Delete Middle Node
 Implement an algorithm to delete a node in the middle of a singly linked list, given only access to that node.
 Note: the node is any node but the first and last node, not necessarily the exact middle.
 EXAMPLE:
 Input: a -> b -> c -> d -> e -> f
 Output: a -> b -> d -> e -> f
 -----------------------------------------------------------------------------------------------------------------------------
Solution:
In this problem, we are not given access to the head of the linked list.
The solution is simply to copy the data from the next node over to the current node, and then delete the next node.
    boolean deleteNode(LinkedListNode node){
        if (n == null || n.next == null){
            return false;
        }
        LinkedListNode next = node.next;
        n.val = next.val;
        n.next = next.next;
        return true;
    }
==============================================================================================================================
4.Partition
Write code to partiton a linked list around a value x, such that all nodes less than x come before all nodes righter than
or equal to x.
EXAMPLE:
    Input: 3 -> 5 -> 8 -> 5 -> 10 -> 2-> 1
    Output: 1 -> 2 -> 3 -> 5 -> 8 -> 5 -> 10
------------------------------------------------------------------------------------------------------------------------------
Solution 1:
Rather than shifting and swapping elements, we can create two different linked lists:
One from elements less than x, one for elements greater than or equal to x.
We iterate through our linked list, inserting elements into before list or after list.
Then we merge the two lists.
This approach is mostly "stable" in that elements stay in their original order.
    LinkedListNode partition(LinkedListNode node, int x){
        LinkedListNode beforeStart = null;
        LinkedListNode beforeEnd = null;
        LinkedListNode afterStart = null;
        LinkedListNode afterEnd = null;
        while (node != null){
            LinkedListNode next = node.next;
            if (node.val < x){
                //Insert node into end of before list
                if (beforeStart == null){
                    beforeStart = node;
                    beforeEnd = beforeStart;
                } else {
                    beforeEnd.next = node;
                    beforeEnd = node;
                }
            } else {
                //Insert node into end of after list
                if (afterStart == null){
                    afterStart = node;
                    afterEnd = afterStart;
                } else {
                    afterEnd.next = node;
                    afterEnd = node;
                }
            }
            node = next;
        }
        if (beforeStaret == null){
            return afterStart;
        }
        //Merge before list and after list
        beforeEnd.next = afterStart;
        return beforeStart;
    }
------------------------------------------------------------------------------------------------------------------------------
Solution 2:
If we don't care about making the elements of the list "stable", then we can instead rearrange the elements by growing 
the list at the head and tail.
In this approach, we start a "new" list(usint the existing node)
Elements bigger than the pivot element are put at the tail, 
and elements less than the pivot elements are put at the head.
Each time we insert an element, we update either the head or tail.
LinkedListNode partition(LinkedListNode node, int x){
        LinkedListNode head = node;
        LinkedListNode tail = node;
        while (node != null){
            LinkedListNode next = node.next;
            if (node.val < x){
                //Insert node at head
                node.next = head;
                head = node;
            } else {
                //Insert node at tail
                tail.next = node;
                tail = node;
            }
            node = next;
        }
        tail.next = null;
        //The head has changed, so we need to return it the user.
        return head;
    }
==============================================================================================================================
5.Sum Lists
You have two numbers represented by a linked list, where each node contains a digit.
The digits are sorted in reverse order.
Write a funciton that adds two numbers and returns the sum as a linked list.
EXAMPLE
Input: (7->1->6) + (5->9->2). That is 617 + 295 = 912
Output:2->1->9
------------------------------------------------------------------------------------------------------------------------------
Solution 1:
First, let's see how exactly addition works.
    6 1 7
  + 2 9 5
  First, we add 5 and 7 to get 12. The 2 becomes the last digit of the number, and 1 gets carried over to the next step.
  Second, we add 1, 1 and 9 to get 11. The 1 becomes the second digit, and the ohter 1 gets carried over the final step.
  Finally, we add 1, 6, 2 to get 9.
  So our value becomes 912.
  We can mimic this process recursively by adding node by node, carrying over any "excess" data to the next node.
  Let's walk through the below linked lists:
    7 -> 1 -> 6
  + 5 -> 9 -> 2
  First, we add 5 and 7, getting a result of 12. 2 becomes the first node in our linked list, and we "carry" the 1 to the next
  sum.
  Second, we add 1, 1 and 9, getting a result of 11. 1 becomes the second node, and we "carry" the 1 to the next sum.
  Finally, we add 1, 2 and 6, getting a result of 9. 9 becomes the final element of the linked list.
  In implementing this code, we must be careful to handle the condition when one linked list is shorter then another.
  We don't want to get a null pointer exception.
  
  LinkedListNode addLists(LinkedListNode l1, LinkedListNode l2, int carry){
        if (l1 == null && l2 == null && carry == 0){
            return null;
        }
        LinkedListNode result = new LinkedListNode(0);
        int value = carry;
        if (l1 != null){
            value += l1.val;
        }
        if (l2 != null){
            value += l2.val;
        }
        result.val = value % 10;
        if (l1 != null || l2 != null){
            LinkedListNode more = addLists(l1 == null ? null : l1.next,
                    l2 == null ? null : l2.next,
                    value >= 10 ? 1 : 0);
            result.next = more;
        }
        return result;
    }
