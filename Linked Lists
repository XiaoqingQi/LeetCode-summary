==============================================================================================================================
1.Remove Duplicates
Write code to remove duplicates from an unsorted linked list.
Follow up:
How would you solve this problem if a temporary buffer is not allowed ?
-----------------------------------------------------------------------------------------------------------------------------
Solution 1: 
In order to move duplicates from a linked list, we need to be able to track duplicates.
A simple hash table will work well here.
We iterate through the linked list, add each element to hash table.
When we found a duplicate element, we remove it and continue iterating.
We can do this all in one pass since we're using linked list.
It will take O(N) time, where N is the number of elements in the linked list.
import java.util.HashSet;

class LinkedListNode{
    int val;
    LinkedListNode next;

    public LinkedListNode(int val) {
        this.val = val;
    }

    public LinkedListNode(int val, LinkedListNode next) {
        this.val = val;
        this.next = next;
    }
}
public class RemoveDuplicates {
    void removeDups(LinkedListNode head){
        HashSet<Integer> hashSet = new HashSet<>();
        LinkedListNode pre = null;
        while (head != null){
            if (hashSet.contains(head.val)){
                pre.next = head.next;
            } else {
                hashSet.add(head.val);
                pre = head;
            }
            head = head.next;
        }
    }
 }
 ---------------------------------------------------------------------------------------------------------------------------
 Solution 2:
 No buffer allowed
 If we don't have a buffer, we can iterate with two pointers: current which iterates through the linked list,
 runner which checks all subsequent nodes for duplicates.
 It will take O(N2) time and O(1) space.
 
 void removeDups(LinkedListNode head){
        LinkedListNode current = head;
        while (current != null){
            LinkedListNode runner = current;
            //Remove future nodes that have the same value
            while (runner.next != null){
                if (runner.next.val == current.val){
                    runner.next = runner.next.next;
                }  else {
                    runner = runner.next;
                }
            }
            current = current.next;
        }
  }
 ==============================================================================================================================
 2.Return Kth to last
 Implement an algorithm to find the kth to last element of a singly linked list.
 Note that if k = 0, the method would return the last element, k = 1 would return the second to last element.
 The linked list size is not known.
 ------------------------------------------------------------------------------------------------------------------------------
 Solution 1:
 Recursive
 We recurses through the linked list.
 When it hits the end, the method passes back a counter set to 0.
 Each parent call adds 1 to this counter.
 When the counter equals to k, we know we have reached the kth to last element of the linked list.
 It will take O(N) space due to the recursive calls.
 But we can't pass back a node and a counter using normal return statements.
 One way to do this is to change the problme to simply printing the kth to last element.
 Then we can pass back the value of the counter simply througt return values.
 int kthToLast(LinkedListNode head, int k){
  if (head == null){
    return 0;
  }
  int index = kthToLast(head.next, k);
  if (index == k){
    System.out.println(k + "th to last node is " + head.val);
  }
  return index;
 }
 Another way is to create a class that stores both the node and the counter, and return an instance of that class.
 ------------------------------------------------------------------------------------------------------------------------------
 Solution 2:
 Iterative
 We can use two pointers, p1 and p2.
 We place them k nodes apart in the linked list by putting p1 at the beginning and moving p2 k nodes into the list.
 Then we move them at the same pace.
 When p2 hit the end of the linked list, p1 would point the kth to last element.
 This algorithm takes O(1) space and O(N) space.
 
 LinkedListNode nthToLast(LinkedListNode head, int k){
  LinkedListNode p1 = head;
  LinkedListNode p2 = head;
  //move p2 k nodes apart from p1
  for (int i = 0; i < k; i++){
    if (p2 == null){
      return null;
    }
    p2 = p2.next;
  }
  while (p2 != null){
    p1 = p1.next;
    p2 = p2.next;
  }
  return p1;
  
 }
 ==============================================================================================================================
 3. Delete Middle Node
 Implement an algorithm to delete a node in the middle of a singly linked list, given only access to that node.
 Note: the node is any node but the first and last node, not necessarily the exact middle.
 EXAMPLE:
 Input: a -> b -> c -> d -> e -> f
 Output: a -> b -> d -> e -> f
 -----------------------------------------------------------------------------------------------------------------------------
Solution:
In this problem, we are not given access to the head of the linked list.
The solution is simply to copy the data from the next node over to the current node, and then delete the next node.
    boolean deleteNode(LinkedListNode node){
        if (n == null || n.next == null){
            return false;
        }
        LinkedListNode next = node.next;
        n.val = next.val;
        n.next = next.next;
        return true;
    }
==============================================================================================================================
4.Partition
Write code to partiton a linked list around a value x, such that all nodes less than x come before all nodes righter than
or equal to x.
EXAMPLE:
    Input: 3 -> 5 -> 8 -> 5 -> 10 -> 2-> 1
    Output: 1 -> 2 -> 3 -> 5 -> 8 -> 5 -> 10
------------------------------------------------------------------------------------------------------------------------------
Solution 1:
Rather than shifting and swapping elements, we can create two different linked lists:
One from elements less than x, one for elements greater than or equal to x.
We iterate through our linked list, inserting elements into before list or after list.
Then we merge the two lists.
This approach is mostly "stable" in that elements stay in their original order.
    LinkedListNode partition(LinkedListNode node, int x){
        LinkedListNode beforeStart = null;
        LinkedListNode beforeEnd = null;
        LinkedListNode afterStart = null;
        LinkedListNode afterEnd = null;
        while (node != null){
            LinkedListNode next = node.next;
            if (node.val < x){
                //Insert node into end of before list
                if (beforeStart == null){
                    beforeStart = node;
                    beforeEnd = beforeStart;
                } else {
                    beforeEnd.next = node;
                    beforeEnd = node;
                }
            } else {
                //Insert node into end of after list
                if (afterStart == null){
                    afterStart = node;
                    afterEnd = afterStart;
                } else {
                    afterEnd.next = node;
                    afterEnd = node;
                }
            }
            node = next;
        }
        if (beforeStaret == null){
            return afterStart;
        }
        //Merge before list and after list
        beforeEnd.next = afterStart;
        return beforeStart;
    }
------------------------------------------------------------------------------------------------------------------------------
Solution 2:
If we don't care about making the elements of the list "stable", then we can instead rearrange the elements by growing 
the list at the head and tail.
In this approach, we start a "new" list(usint the existing node)
Elements bigger than the pivot element are put at the tail, 
and elements less than the pivot elements are put at the head.
Each time we insert an element, we update either the head or tail.
LinkedListNode partition(LinkedListNode node, int x){
        LinkedListNode head = node;
        LinkedListNode tail = node;
        while (node != null){
            LinkedListNode next = node.next;
            if (node.val < x){
                //Insert node at head
                node.next = head;
                head = node;
            } else {
                //Insert node at tail
                tail.next = node;
                tail = node;
            }
            node = next;
        }
        tail.next = null;
        //The head has changed, so we need to return it the user.
        return head;
    }
==============================================================================================================================
5.Sum Lists
You have two numbers represented by a linked list, where each node contains a digit.
The digits are sorted in reverse order.
Write a funciton that adds two numbers and returns the sum as a linked list.
EXAMPLE
Input: (7->1->6) + (5->9->2). That is 617 + 295 = 912
Output:2->1->9
------------------------------------------------------------------------------------------------------------------------------
Solution 1:
First, let's see how exactly addition works.
    6 1 7
  + 2 9 5
  First, we add 5 and 7 to get 12. The 2 becomes the last digit of the number, and 1 gets carried over to the next step.
  Second, we add 1, 1 and 9 to get 11. The 1 becomes the second digit, and the ohter 1 gets carried over the final step.
  Finally, we add 1, 6, 2 to get 9.
  So our value becomes 912.
  We can mimic this process recursively by adding node by node, carrying over any "excess" data to the next node.
  Let's walk through the below linked lists:
    7 -> 1 -> 6
  + 5 -> 9 -> 2
  First, we add 5 and 7, getting a result of 12. 2 becomes the first node in our linked list, and we "carry" the 1 to the next
  sum.
  Second, we add 1, 1 and 9, getting a result of 11. 1 becomes the second node, and we "carry" the 1 to the next sum.
  Finally, we add 1, 2 and 6, getting a result of 9. 9 becomes the final element of the linked list.
  In implementing this code, we must be careful to handle the condition when one linked list is shorter then another.
  We don't want to get a null pointer exception.
  
  LinkedListNode addLists(LinkedListNode l1, LinkedListNode l2, int carry){
        if (l1 == null && l2 == null && carry == 0){
            return null;
        }
        LinkedListNode result = new LinkedListNode(0);
        int value = carry;
        if (l1 != null){
            value += l1.val;
        }
        if (l2 != null){
            value += l2.val;
        }
        result.val = value % 10;
        if (l1 != null || l2 != null){
            LinkedListNode more = addLists(l1 == null ? null : l1.next,
                    l2 == null ? null : l2.next,
                    value >= 10 ? 1 : 0);
            result.next = more;
        }
        return result;
    }
==============================================================================================================================
6.Follow up 5
Suppose the digits are stored in forward order. Repeat the problem.
Input: (6 -> 1 ->7) + (2 -> 9 -> 5)
Output: 9 -> 1 -> 2
-----------------------------------------------------------------------------------------------------------------------------
Solution:
One list maybe shorter than the other. For example, suppose we were add (1->2->3->4) and (5->6->7).
We need to know that the 5 should be matched with 2, not the 1.
We could solve this issue be comparing the lengthts of the lists in the beginning and padding the shorter list with zeros.
We need to add corresponding digits and pass the carry to the head(passed backward).
We use a wrapper class to solve the problem.

    class PartialSum {
        public LinkedListNode sum = null;
        public int carry = 0;
    }
    LinkedListNode addLists(LinkedListNode l1, LinkedListNode l2){
        int len1 = length(l1);
        int len2 = length(l2);
        //Pad the shorter list with zeros
        if (len1 < len2){
            l1 = padList(l1, len2 - len1);
        } else {
            l2 = padList(l2, len1 - len2);
        }
        //Add lists
        PartialSum sum = addListHelper(l1, l2);
        if (sum.carry == 0){
            return sum.sum;
        } else {
            LinkedListNode result = insertBefore(sum.sum, sum.carry);
            return result;
        }
    }
    private PartialSum addListHelper(LinkedListNode l1, LinkedListNode l2){
        if (l1 == null && l2 == null){
            PartialSum sum = new PartialSum();
            return sum;
        }
        //Add smaller digits recursively
        PartialSum sum = addListHelper(l1.next, l2.next);
        //Add carry to current data
        int val = sum.carry + l1.val + l2.val;
        //Insert sum of current digits
        LinkedListNode full_result = insertBefore(sum.sum, val % 10);

        //Return sum so far, and the carry value
        sum.sum = full_result;
        sum.carry = val / 10;
        return sum;
    }

    private LinkedListNode padList(LinkedListNode l, int num) {
        LinkedListNode head = l;
        for (int i = 0; i < num; i++){
            head = insertBefore(head, 0);
        }
        return head;
    }

    private LinkedListNode insertBefore(LinkedListNode head, int data) {
        LinkedListNode node = new LinkedListNode(data);
        if (head != null){
            node.next = head;
        }
        return node;
    }
==============================================================================================================================
6. Palindrome
    Implement a function to check if a linked list is a palindrome.
-----------------------------------------------------------------------------------------------------------------------------
Solution 1 :
We know that, since it's palindrome, the linked list must be the same backwards and forwards.
So we could reverse the linked list and compare the reversed list to the original list.
If they are the same, the lists are identical.

boolean isPalindrom(LinkedListNode head){
        LinkedListNode reversed = reversedAndClone(head);
        return isEqual(head, reversed);
    }

    private  boolean isEqual(LinkedListNode l1, LinkedListNode l2){
        while (l1 != null && l2 != null){
            if (l1.val != l2.val){
                return false;
            }
            l1 = l1.next;
            l2 = l2.next;
        }
        return l1 == null && l2 == null;
    }
    private LinkedListNode reversedAndClone(LinkedListNode node) {
        LinkedListNode head = null;
        while (node != null){
            LinkedListNode n = new LinkedListNode(node.val);
            n.next = head;
            head = n;
            node = node.next;
        }
        return head;
    }
-----------------------------------------------------------------------------------------------------------------------------
Solution 2: Iterative Approach
We want to detect linked list where the front half of the list is the  reverse of the second half.
We could solve this issue by reversing the front half using a stack.
As we don't know the size of the linked list, we can iterate through the linked list, suing fast pointer and slow pointer.
At each step in the loop, we push the data from the slow pointer onto a stack.
When the fast pointer hits the end of the linked list, the slow point will have reached the middle of the list.
Then the stack will have all the elements from the front half of the list, but in revers order.
Now, we simply iterate through the rest of the list, and compare the node to the top of the stack.

    boolean isPalindrome(LinkedListNode node){
        LinkedListNode fast = node;
        LinkedListNode slow = node;
        Stack<Integer> stack = new Stack<>();
        //Put the element from the front half onto stack
        while (fast != null && fast.next != null){
            stack.push(slow.val);
            fast = fast.next.next;
            slow = slow.next;
        }
        //Has add number of elements, so skip the middle element
        if (fast != null){
            slow = slow.next;
        }
        while (slow != null){
            int top = stack.pop();
            //If values are different, then the list is not palindrome
            if (top != slow.val){
                return false;
            }
            slow = slow.next;
        }
        return true;
    }
-----------------------------------------------------------------------------------------------------------------------------
Solution 3: 
